---
layout: post
title:  "Less Code"
date:   2016-03-26
---
<p>
These days I increasingly feel that I am in a minority in my deep appreciation &ndash; love, even &ndash; of the heaviest weight of heavyweight dynamic MVC web frameworks: Ruby on Rails. I have worked, now, with many of the more popular frameworks on both the server and client side. Flask, Django, Web.py, React, Angular, Express JS, Sinatra and others. I still come back to Rails.
</p>

<p>
I belive that, for the overwhelming majority of domains, it is the tool &ndash; if weilded with healthy reverence for its conventions and idioms &ndash; which leads to the most manageable, consistent, non-redundant and all-around sane codebases. Of course, as with any other tool, it is possible to create hopeless messes with Rails. These hopeless messes, also as with any other tool, are probably far more prevalent in the wild than sane, manageable, idiomatic temples.
</p>

<p>
Nearly every "scaling" or "complexity" gripe that I have heard leveled at Rails in my time with it is fact a complaint about non-idiomatic use of the framework. I still routinely stumble on codebases that make zero use of key-based fragment caching (an innovation that elevated Rails far above many other frameworks in performance when it came to real-life application - not just framework benchmarking), poor or incorrect use of the ActiveRecord query interface, poor domain modeling (failing to see when validations or logic belong on relations, for instance, and not in the related objects), failure to design properly DRY controllers (failure to use exception-based control flow and filters where appropriate), heavy integration of and reliance on obviously poorly maintained dependencies, and much, much more.
</p>

<p>
So accepting now that one can &ndash; and, in fact, people often do &ndash; make horrible messes of applications they implement with Rails, I will continue to devote myself to its idiomatic application until something comes along that does it all better in the real world. And my real world metrics of success are modest: <strong>"is there less code?", "is it easier to read?", "does it break less?"</strong>. Academic cases for purity should always take a back seat if they result in an outcome that is many times worse by these practical metrics, which is often the reality.
</p>

<p>
In this time when choices at all levels of your stack abound like never before, it pays to be mindful of what your real-world metrics of success are, and to honestly weigh how closely your stack is aligned with them.
</p>
